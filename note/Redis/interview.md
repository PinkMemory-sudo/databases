

**缓存穿透，雪崩，击穿**

穿透：访问的key在redis和数据库中都没有，导致每次都从缓存中找不到而去查数据库。若黑客利用此漏洞进行攻击可能压垮数据库。

击穿：一个key过期，此时大量请求来访问这个key就会都去请求DB，而打垮DB

雪崩：当重启等造成大量key同事失效，大量请求取访问DB从而打垮DB



**解决方案**

***穿透***

1. 布隆过滤器
2. 查不到的也进行缓存，使它不去在查DB

***击穿***

1. 使用互斥锁

当缓存失效时，首先不是去查DB，而是只要一个线程需查DB，其他线程尝试获得缓存。最常见的就是通过一个setnx(此key不存在才会赋值成功)，每个线程都setnx，所以只有一个线程能set这个key，只有setkey成功的线程才取查询DB，然后缓存，其他线程都尝试读取。

伪代码：

```java
public String get(key) {
  String value = redis.get(key);
  // 缓存过期
  if (value == null) { 
    //设置3min的ttl,赋值成功相当于拿到锁了
    if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  
      value = db.get(key);
      redis.set(key, value, expire_secs);
      redis.del(key_mutex);
    } else {  
      // 没拿到锁的，重试获取缓存值
      sleep(50);
      get(key);
    }
  } else {
    return value;      
  }
}

```

***雪崩***

为了防止大片key失效从而打挂DB，需要使过期时间分散开

1. 过期时间添加随机值





**redis的六中淘汰策略**



**如何限制每分钟客户发送验证码的个数**

设置key的过期时间为60s



**每天只能获得三次验证码**

使用list，第一次获得时设置key有效期为1天，之后获得验证码需要判断list中的个数



**redis是单线程，单进程的？**









# Basic



**什么是redis**

redis是一个基于内存的键值对数据库，所有数据保存再内存中，然后定时把数据持久化到磁盘上。



**redis的优点**

* 基于内存，性能出色
* 支持持久化
* 数据类型丰富



**reids如何设置密码**

* 通过命令
* 通过设置配置文件



**redis中的管道有什么用**

 Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应 。



**如何做大量数据插入**



**怎么设置redis的过期时间和永久有效**

`expore key seconds`

`persist key`



**redis的Java客户端**

jedis，lettuce，redisson



**jedis与detission的区别**

redisson，分布式的



**redis回收进程如何工作**

一条命令添加了新数据后会检查内存使用情况，如果大于maxmemory，则按照设置的淘汰策略进行回收。



**redis为什么要将数据放在内存中**

为了快速读写和异步写入磁盘，如果不在内存中，磁盘I/O回严重影响redis性能



**字符串类型的value最大容量**

512M，其他的是(2^32)-1个



**redis持久化的几种方式，优缺点**

 RDB(Redis DataBase)和AOF(Append Only File)。 应为redis是内存数据库，所以如果没有配置持久化，那么重启redis后数据就没了。

**两者的区别**

RDB是定时fork一个子进程，先将数据集写入一个临时文件，写入成功后再替换旧的文件，然后二进制压缩存储。

AOF记录的是操作记录(不含查询的命令)，AOP对日志的写入时Append的，所以出错也不影响之前的内容

**两者的使用场景**

如果要求数据的高可用，尽量保证数据不丢失，那么RDB不适合

AOF文件要比RDB大，所以再恢复的时候要慢，读写效率要比RDB低





**redis的同步机制**



**内存用完后redis会怎么办**

redis的淘汰策略

1. 当内存达到限制时返回错误而不清除数据
2. 尝试回收最少使用的key(LRU)
3. 尝试回收过期key中最少使用的key(LRU)
4. 随机回收一个
5. 过期的key中随机回收一个
6. 过期的key回收存活时间短的



**过期键的删除策略**



**一个redis实例可以有多少key，五种数据类型他们能放多少元素**



**怎么使用redis做异步队列**



**为什么要做redis分区**



**redis分区的实现方案**



**redis分区的缺点**



**持久化数据和缓存怎么做扩容**



**twemproxy是什么**



**支持一致性hash的客户端**



**修改配置不重启会生效吗**



**为什么redis要是单线程的**

 Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了 。Redis利用队列技术将并发访问变成串行访问，消除了传统数据库串行控制的开销。



**redis是单线程的为什么还这么快**

* 基于内存，减少了IO消耗
* 单线程减少了上下文切换的消耗
* 使用多路复用技术，可以并发处理连接(多个连接复用一个线程)



**redis的并发竞争关系如何解决**

Redis利用队列技术将并发访问变成串行访问，Redis本身没有锁的概念，多个连接不存在竞争关系。但是在客户端对redis进行并发访问时hi发生连接超时，数据转换错误，阻塞等问题，这些问题时客户端连接混乱造成的。

解决方案：

方案1：使用连接池，对客户短的读写操作进行synchronized

方案2：利用setnx实现锁







**redis的内存模型**



**进程本身需要的内存**



**缓冲内存**



**内存碎片**



**持久化触发条件**



**开启AOF**



**AOF常用配置**



**持久化策略的选择**



**布隆过滤器**



**redis的通信协议**



**scan命令系列的注意条件**



**常见的几种缓存策略**





# 事务





**redis事务**

1. 事务中的所有命令都会序列化，按顺序执行，事务在执行过程中不会被其他客户端的请求打断。
2. redis事务中如果有一条命令执行失败，其后的命令仍然会接着执行
3. 通过mulit开启事务，通过exec/discard结束事务/回滚



**redis事务相关的命令**

multi，exec，discard，watch



**watch命令和基于CAS的乐观锁**

redis中watch命令可以提供CAS功能。使用watch来监控key













# 集群



**redis集群都有哪些方案**

主从赋值

哨兵模式

Cluster集群





**分布式是前期做好，还是规模上来后再做好**



**什么情况下会导致集群不可用**

在没有复制模型的情况下，如果一个节点失败了，则hash槽就不完整了，从而不可用



**读写分离模型**



**数据分片模型**



**redis哨兵**



**redis集群的主从复制模型**



**redis集群会有写丢失吗？**



**redis集群之间如何复制**



**redis集群的最大节点个数**



**redis集群如何选择数据库**

Redis 集群目前无法做数据库选择，默认在 0 数据库。 



**怎么测试redis的连通性**



**redis哈希槽的概念**

redis集群有16384个哈希槽，每个节点分一部分哈希槽。每个key校验后通过对1384取模获得应该放入哪个hash槽，



**redis分布式锁的实现**





# 优化



**redis如何做内存优化**

尽量使用hashes，比如一个对象不要为name，email等单独设置key，而是使用hashes



**redis常见性能问题与解决方案**





**降低内存使用情况的做法**



**redis是单线程的，则呢么提高多核cpu利用率**



**手写LRU算法**



# 锁



**redis分布式锁怎么实现**



**如何实现集群中的session共享**



**多节点分布式锁Redlock算法**



**redis实现附近的人**



**MySQL中存100w数据，Redis中存20w数据，如何保证redis中存的都是热点数据**

redis的淘汰策略



**redis的使用场景**

* 排行榜/计数器
* 发布订阅功能





