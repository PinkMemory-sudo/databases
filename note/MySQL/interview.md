# MySQL



**数据库的六层范式**

终极目标是为了减少数据的冗余，一般情况下只有前三种范式需要满足

1NF:所有字段都是不可分割的

2NF:属性完全依赖于主键，没有部分依赖组件的属性

3NF:解决依赖传递问题



## 数据类型



**数值类型**

| 类型         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| INT或INTEGER | int(m)里的m并不影响实际的取值范围，它代表的是数据在显示时显示的最小长度 |
| BIGINT       |                                                              |
| FLOAT        |                                                              |
| DOUBLE       |                                                              |
| DECIMAL      | DECIMAL(M,D)，m是总长度，d是小数位个数,decimal(10, 0)以字符串形式进行保存的 |
| TINYINT      |                                                              |
| SMALLINT     |                                                              |
| MEDIUMINT    |                                                              |

可以在后面加 unsigned，表示无符号



**int(n),n代表什么意思**

* 无论n等于多少，int永远占4个字节
* n表示的是显示宽度，不足的用0补足，但这要整型设置了unsigned zerofill才有效。超过的无视长度而直接显示整个数字，所以准确来说n表示的是显示的最小的位数



**日期和时间类型**

| 类型      | 描述 |
| --------- | ---- |
| DATE      |      |
| TIME      |      |
| DATETIME  |      |
| TIMESTAMP |      |
| YEAR      |      |



 **datetime与 timestamp的区别**

* datetime的默认值是null，timestamp的默认值是当前时间
*  datetime存储的时间与时区无关，timestamp存储的时间及显示的时间都依赖于当前时区 
*  datetime占8个字节，timestamp占4个字节 所以存储的范围不一样



**MySQL的创建时间和修改时间怎么自动更新**

方案1：创建表的时候指定

```mysql
...
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
...
```



方案2：修改字段

```mysql
ALTER TABLE `course`
MODIFY COLUMN `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;
ALTER TABLE `course`
ADD COLUMN `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间' ;
```





**字符串类型**

| 类型       | 描述                            |
| ---------- | ------------------------------- |
| char       |                                 |
| varchar    |                                 |
| TIMYBLOB   | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   |                                 |
| BLOB       | 二进制形式的长文本数据          |
| TEXT       |                                 |
| MEDIUMBLOB |                                 |
| MEDIUMTEXT |                                 |
| LONGBLOB   |                                 |
| LONGTEXT   |                                 |

char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。



**Blog和Text的区别**



**记录货币用什么类型好**



## 视图



**什么是视图**

通俗的讲，视图就是一条SELECT语句执行后返回的结果集，不存储具体的数据，而是存储视图的定义。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。视图是一张虚拟的表，具有和物理表相同的功能，对视图的修改会影响基本表。



**视图的优点**

方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性，视图可以隐藏表表间的复杂关系。

更加安全，数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别；



**使用场景**

* 授权：客户想要直接查询数据库，不希望用户访问表中某些含敏感信息的列，可以创建视图和用户，将视图授权给用户。

* 表连接：关键信息来源于多个复杂关联表，可以创建视图提取我们需要的信息或者有的时候，由于表中的数据量太大，需要对表进行拆分，这样会导致表的结构发生变化，导致用户的应用程序受到影响，这时我们就可以使用视图来屏蔽实体表间的逻辑关系，去构建应用程序所需要的原始表关系




**视图的分类**

* MERGE：将视图的sql语句和引用视图的sql语句合并在一起，最后一起执行。

* TEMPTABLE： 将视图的结果集存放在临时表中，每次执行时从临时表中操作。

* UNDEFINED： 默认的视图类型，DBMS倾向于选择而不是必定选择MERGE，因为MERGE的效率更高，更重要的是临时表视图不能更新。

所以，这里推荐使用MERGE算法类型视图。



**怎么创建视图**

```mysql
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER
VIEW `视图名` AS (
    select ...
);
```

ALGORITHM=UNDEFINED：指定视图的处理算法；

DEFINER=`root`@`localhost`：指定视图创建者；

SQL SECURITY DEFINER：指定视图查询数据时的安全验证方式；



**怎么使用视图**

将视图名当成表名

```mysql
select
视图名.属性
from 视图
```



## 游标

不常用  



**什么是游标**

是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。



**一条SQL语句在MySQL中如何执行的**

[一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd)



## 存储过程



**什么是存储过程，怎么调用**

一组为了完成特定功能预编译的SQL 语句集，一次编译后永久有效。如果某次操作需要执行多句 SQL，使用存储过程比单纯 SQL语句执行要快。
调用：

* 可以用一个命令对象来调用存储过程。

* 可以供外部程序调用，比如：java 程序。



**存储过程的优点**

* 存储过程是预编译过的，执行快。
* 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
* 安全性高，执行存储过程需要有一定权限的用户。
* 存储过程可以重复使用，可减少数据库开发人员的工作量。缺点：移植性差





## 触发器



**什么是触发器**

触发器是特殊的存储过程，通过事件触发执行。用来维护数据的完整性和一致性。







## CRUD



**内连接，外链接什么意思**

内连接：只连接匹配的行

外连接分为左外连接，右外连接和全连接



**count(*)、count(1)、count(column)的区别**

执行结果：count(*)和count(1)没有区别，都不会过滤空值，count(column)不包含空值

执行效率：MyISAM 引擎会把一个表的总行数记录了下来，所以在执行 count(*) 的时候会直接返回数量，执行效率很高，5.5后MySQL的默认存储引擎是InnoDB，因为增加了版本控制(MVCC)的原因，同时有多个事务访问数据并且有更新操作的时候，每个事务需要维护自己的可见性，那么每个事务查询到的行数也是不同的，所以不能缓存具体的行数，他每次都需要 count 一下所有的行数。`InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way There is no performance difference`



**最左匹配原则**

**即创建联合索引时，识别度最高的放在查询语句前面**



## 存储引擎



**存储引擎的功能**



**都有哪些存储引擎**

* MyISAM
* InnoDB
* Memory



**MyISAM和InnoDB的区别**

|        | 事务                     | 外键                     | 行级锁                   | MVCC                     | 全文索引                 |
| ------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |
| MyISAM | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_check_mark:       |
| InnoDB | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_multiplication_x: |

* 5.5版本后默认的存储引擎为InnoDB，之前是MyISAM
* 事务：MyISAM不支持事务
* 锁： MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row- level locking)和表级锁,默认为行级锁。
* 外键：MyISAM不支持外键
* MVCC：仅InnoBD支持，应对高并发事务, MVCC比单纯的加锁更高效;
* 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表

MyISAM强调性能，但是也不一定比InnoDB快，尤其是使用到聚簇索引的时候



**使用场景**

* MyISAM适合查询以及插入为主的应用，
* InnoDB适合频繁修改以及涉及到安全性较高的应用

* InnoDB：需要事务和外键约束时，可以冲灾难中恢复



**bin-log日志**



**InnoDB的page**

一般16k



**什么是MVCC**



**数据库中间件**









**MySQL都有哪些触发器**



**SQL语句的主要分类**



**主键，外键，候选见，超键分别指什么**



**SQL约束**



**六种关联查询**



**什么是子查询**



**in和exists的区别**



**varchar和char的区别**



**MySQL与Oracle的区别**

* Oracle收费
* 分页不同，MySQL是limit，Oracle是row
* Oracle没有自动增长类型



## 性能优化



* 加索引
* 避免返回不必要的字段
* 
* 适当分批操作
* 分库分表
* 读写分离



**MySQL高性能优化规范建议**

[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd)



[腾讯面试:一条SQL语句执行得很慢的原因有哪些?---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd)



[后端程序员必备:书写高质量SQL的30条建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)



小表驱动大表



 **解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?****

创建线程，获得连接都有开销，我们可以预先创建好一些资源，以便将来 需要对数据库的请求时可以重用这些连接，减少资源和时间的浪费。



**大表优化**

[大表优化方案](https://segmentfault.com/a/1190000006158186)

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常⻅的优化措施如下：

* 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。
* 读**/**写分离：主库负责写，从库负责读;
* 垂直分区：把一张列比较多的表拆分为多张表。
* 水平分区：保持数据表结构不变，每一片数据分散到不同的表或者库中，分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库。



**垂直分表和水平分表的优缺点**

垂直分表

可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。但主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用 层进行Join来解决。此外，垂直分区会让事务变得更加复杂;

水平分表

支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join 性能􏰁差，逻辑复杂



**数据库分片的两种常⻅方案**

* 客户端代理: 分片逻辑在应用端，封装在**jar**包中，通过修改或者封装**JDBC**层来实现。 当 当网的 **Sharding-JDBC** 、阿里的TDDL是两种比􏰁常用的实现。
* 中间件代理: 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我 们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。



**分库分表之后,id 主键如何处理**

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持。

* UUID:不适合作为主键，因为太⻓了，并且无序不可读，查询效率低。比􏰁适合用于生成 唯一的名字的标示比如文件的名字。
* 数据库自增 id : 两台数据库分别设置不同步⻓，生成不重复ID的策略来实现高可用。这种方 式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
* 利用 redis 生成 id : 性能比􏰁好，灵活方便，不依赖于数据库。但是，引入了新的组件造成 系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
* Twitter的snowflake算法 :Github 地址:https://github.com/twitter-archive/snowflake。 美团的Leaf分布式ID生成系统 :Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、 趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系 数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章:https://tech.meitua n.com/2017/04/21/mt-leaf.html 。







## **SQL优化**



* 不要使用select *，查什么写上，查全部使MySQL优化器失去了索引覆盖的可能，增加了IO和网络开销
* 避免使用in,not in,会使数据库进行全表扫描，连续值可以用between代替，子查询可以用exists代替
* 尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描。优化方式：可以给字段添加默认值 0，对 0 值进行判断。
* 避免左模糊查询



**分库分表的设计**



**limit100000分页很慢怎么解决**

* 如果id是连续的，可以通过添加where条件id>100000



**分布式主键设计方案**





**查询缓冲**

修改配置文件开启缓冲，当查询的表和查询条件都没有变化时可以使用缓存，否则缓存失效。MySQL 8.0 版本后移除，因为这个功能不太实用，缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一 次缓存操作，失效后还要销毁。





## 索引



组合索引(k1,k2,k3)相当于创建了三个索引(k1),(k1,k2),(k1,k2,k3)



**什么是索引**

就像字典的目录，可以根据拼音和笔画进行查询。索引就是将所有保存的数据，按照指定的规则进行排序，生成排序字段到存储地址的一个映射。



**索引的弊端**

* 增加了数据库的存储空间
* 在插入和修改数据时要花费较多的时间(因为索引也要随之变动)



**MySQL索引的数据结构**

B树和B+树



**什么是B树**





**什么是B+树**

B+树是一种多路平衡查找树，他的



**B+树的叶子节点都存放了哪些数据**

可能存储的时整行的数据(主键索引，聚簇索引)，也可能时主键的值



**B树与B+树的区别**



**B树和hash的对比**

hash索引的底层数据结构是hash表，是以键值对的形式存储的，所以进行等值查询的效率高，但是进行区间查询时就需要扫描全表。

B+树是一种多路平衡查找树，他的节点是有序的，进行范围查询不用扫描全表。



**B树和平衡二叉树的区别**



**索引的分类**

单列索引

* 普通索引
* 唯一索引
* 主键索引

组合索引

多个字段组合创建的索引，当查询条件中使用了这些字段最左边的字段时才会生效，也遵循最左匹配原则

全文索引

只有MyISAM支持，只能作用在char，varchar和text。通过一句话中的某个单词找到这条记录



**主键索引和唯一索引的区别**

* 主键索引是非空且唯一的，唯一索引可以有空的



**什么是聚簇索引**

聚簇索引不是索引的一种种类，而是一种存储方式，数据和索引放在一起。聚簇表示数据行和相邻的键值紧凑的存储在一起。因为无法同时将数据行存储在两个位置，所以一个表只能有一个聚簇索引。



**聚簇索引的优势**

减少IO

* 对范围查询
* 适合排序



**聚簇索引和非聚簇做因的区别**

* 聚簇索引的树的叶子节点存放的是整个记录
* 非聚簇索引的叶子节点存放的是主键，当查询的字段不是索引时，就需要根据主键再去聚簇索引中取值(回表)



**非聚簇索引一定会回表查询吗，非覆盖索引**

非聚簇索引叶子节点不存出数据，如果向获得其他数据，就要再去聚簇索引中拿，而如果查询的字段是索引中的，就可以直接返回。(索引覆盖)



**索引覆盖**

要查询的字段，都在当前使用的索引中，走完索引就不需要回表了。即要查询的字段索引已经覆盖了，不需要回表。



**索引下推**

MySQL5.6引入了索引下推。

索引下推的作用就是减少了回表的操作。

没有ICP的情况

- 存储引擎读取索引记录；
- 根据索引中的主键值，定位并读取完整的行记录；
- 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

使用ICP的情况下，查询过程如下：

- 读取索引记录（不是完整的行记录）；
- 判断`WHERE`条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
- 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。





**联合索引是什么，为什么要注意联合索引的顺序**











**怎么创建索引**

创建普通索引：`CREATE INDEX (自定义)索引名 ON 数据表(字段);`

创建符合索引：`CREATE INDEX (自定义)索引名 ON 数据表(字段，字段，...);`



**什么样的字段适合建立索引**

* 经常作为查询条件以及排序和分组条件，联结条件的
* 值差异性大的
* 索引的字段的值很长时，最好使用字段值的前缀来进行索引(创建索引时，在索引的字段后加括号指定长度)， MySQL中无法使用前缀索引进行ORDER BY和GROUP BY 
* 不能创建过多的索引，删除不要的索引，尽量扩展索引而不是新建索引



**怎么删除索引**

`删除索引：DROP INDEX 索引名;`



**怎么查看查询中用到的索引**

`explain`可以查看可用的索引和实际使用的索引



**什么情况索引会失效**

* like以%开头
* or语句前后没有同时使用索引
* 在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引
* 在索引字段上使用not，<>，!=。会扫描全表
* 对索引字段进行计算操作、字段上使用函数
* 字符串不加引号，如varchar不加单引号的话可能会自动转换为int型
* 没有使用组合索引的第一列索引
* 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效





IO次数就是树的高度



**磁盘页**





**自增的主键会遇到什么问题**





**使用索引一定能提高性能吗**



**和作用，使用场景**







## 事务



**什么是事务**

事务就是将多个操作看成是一个原子性的操作，要么成功，要么所有事务都失败。



**事务的四大特性(ACID)**

* 原子性 将多个操作看成一个操作，要么都成功，要么都失败，失败后回滚，不能对数据库造成影响。
* 一致性 事务前后数据库的完整性约束不会收到破坏
* 隔离性 多个事务间不能相互影响，同一时间只允许一个事务操作同一个数据
* 持久性  事务提交后，接下来的操作或故障不会对持久化的数据造成影响



**什么是赃读幻读不可重读**

* 赃读，读取到其他事务中还没提交的数据，其他数据回滚时读到的数据就是脏数据
* 不可重读，一个事务多次读取数据，期间另一个事务修改了数据，导致读取的数据前后不一样
* 幻读，一个事务读取多行，另一个事务期间插入了几行，导致前后读取到的行数不一致



**事务的隔离级别，MySQL的默认隔离级别是什么**

***读取未提交：***一个事务读取到了另一个事务还没提交的数据，造成赃读，不可重读，和幻读

***读取已提交：***一个事务可以读取已提交的事务，造成不可重读，和幻读

***可重读：***一个事务中多次读取到的结果都是一样的，造成、幻读

***串行读：***完全符合ACID，事务一个一个执行

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**(可重读)

InnoDB虽然采用的是可重读的隔离级别，下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到 **SERIALIZABLE(**可串行化**)** 隔离级别。



**表级锁和行级锁对比**

* 表级锁: MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消 耗也比􏰁少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最 低，MyISAM和 InnoDB引擎都支持表级锁。
* 行级锁: MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大 大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会 出现死锁。



**乐观锁和悲观锁**

悲观锁如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。

乐观锁每次去拿数据的时候都认为别人不会修改数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据

乐观锁适合在多读的应用类型，这样可以提高吞吐量，如果经常插入，产生冲突的可能性就比较大，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。



**InnoDB存储引擎的三种锁的算法**

* Record lock:单个行记录上的锁

* Gap lock:间隙锁，锁定一个范围，不包括记录本身 
* Next-key lock:record+gap 锁定一个范围，包含记录本身



**行锁和表锁的使用场景**



**MySQL的死锁**





**什么是MVVC**



**百万级别以上的数据如何删除**



**MySQL都有哪些锁**



**隔离级别与锁的关系**



**MySQL的乐观锁悲观锁怎么实现**



## 权限



**MySQL有关权限的表**



**MySQL的binlog有几种录入格式，有什么区别**



**count(*)、count(1)、count(column)的区别**





## 函数









**Hash 索引和 B+树索引的区别**







**为什么不都用 Hash 索引而使用 B+树索引**



**B 树和 B+树的区别**



**MySQL 三种锁的级别**



**索引的分类**



**聚集索引和非聚集索引区别**



**主键约束和唯一约束的对比**

唯一，非空，个数，组合列



**TRUNCATE与DELETE的区别**

* TRUNCATE用来清空整张表，效率高
* 自增约束，TRUNCATE从1开始，DELETE继续往后
* TRUNCATE不支持回滚
* TRUNCATE后没有返回值，DELETE后返回受影响的函数





* 红黑树？

**一个B+树的节点中到底存多少个元素最合适**



Mysql的基本存储结构是**页**



B Tree又称为平衡多路查找树



**JDBC使用步骤**



**什么是SQL预编译**

 很多情况下，一条SQL语句可能会反复执行，或者每次执行的时候只有个别的值不同。指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。 



 **PreparedStatement为什么能在一定程度上防止SQL注入？** 

 在使用参数化查询的情况下，数据库不会将参数的内容视为SQL执行的一部分，而是作为一个字段的属性值来处理，这样就算参数中包含破环性语句（or ‘1=1’）也不会被执行。 





# MyBatis



**什么是MyBatis**



